% Generated by roxygen2 (4.0.2): do not edit by hand
\name{compute.indices.for.stripe}
\alias{compute.indices.for.stripe}
\title{Compute Climdex indices for a subset / stripe}
\usage{
compute.indices.for.stripe(subset, cdx.funcs, ts, base.range, dim.axes, v.f.idx,
  variable.name.map, src.units, dest.units, t.f.idx, thresholds.name.map,
  fclimdex.compatible = TRUE, projection = NULL, f, thresholds.netcdf)
}
\arguments{
\item{subset}{The subset to use.}

\item{cdx.funcs}{The functions to be applied to the data, as created by \code{\link{get.climdex.functions}}.}

\item{ts}{The associated time data, as created by \code{nc.get.time.series}.}

\item{base.range}{The base range; a vector of two numeric years.}

\item{dim.axes}{The dimension axes for the input data.}

\item{v.f.idx}{A mapping from variables to files, as created by \code{\link{get.var.file.idx}}.}

\item{variable.name.map}{A mapping from standardized names (tmax, tmin, prec) to NetCDF variable names.}

\item{src.units}{The source units to convert data from.}

\item{dest.units}{The destination units to convert to.}

\item{t.f.idx}{A mapping from threshold variables to threshold files, as created by \code{\link{get.var.file.idx}}.}

\item{thresholds.name.map}{A mapping from standardized names (tx10thresh, tn90thresh, etc) to NetCDF variable names.}

\item{fclimdex.compatible}{Whether to make the results identical to those of fclimdex; this affects how the data in the base period is padded.}

\item{projection}{A proj4 string representing the projection the data is in.}

\item{f}{A list of objects of type \code{ncdf4}, consisting of the open input files. If missing, will be pulled from the global namespace.}

\item{thresholds.netcdf}{A list of objects of type \code{ncdf4}, consisting of the open threshold files. If missing, will be pulled from the global namespace.}
}
\description{
Compute Climdex indices for a subset / stripe
}
\details{
Given a subset, a set of Climdex functions (as created by \code{\link{get.climdex.functions}}), and ancillary data, load and convert data, create a climdexInput object for each point, run all of the functions in \code{cdx.funcs} on that data, and return the result.
}
\note{
This function relies on an object named 'f' and containing the opened NetCDF files being part of the global namespace.
}
\examples{
\donttest{
## Define mappings and filenames.
author.data <- list(institution="Looney Bin", institution_id="LBC")
input.files <- c("pr_NAM44_CanRCM4_ERAINT_r1i1p1_1989-2009.nc")
variable.name.map <- c(tmax="tasmax", tmin="tasmin", prec="pr")

## Open files, etc.
cdx.funcs <- get.climdex.functions(get.climdex.variable.list("tmax"))
f <- lapply(input.files, ncdf4::nc_open)
f.meta <- create.file.metadata(f, variable.name.map)
climdex.var.list <- get.climdex.variable.list(names(f.meta$v.f.idx), "all", NULL)
cdx.meta <- get.climdex.variable.metadata(climdex.var.list, input.files[1])

## Compute indices for stripe
cdx <- compute.indices.for.stripe(list(Y=1), cdx.funcs, f.meta$ts, c(1981, 1990), f.meta$dim.axes,
                           f.meta$v.f.idx, variable.name.map, f.meta$src.units, f.meta$dest.units,
                           t.f.idx, NULL, f=f, thresholds.netcdf=NULL)
}
}

